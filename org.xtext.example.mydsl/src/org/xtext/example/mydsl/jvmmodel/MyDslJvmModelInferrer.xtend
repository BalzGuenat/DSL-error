/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.jvmmodel

import com.google.inject.Inject
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.xtext.example.mydsl.myDsl.DomainModel
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.common.types.JvmGenericType
import java.util.Map
import org.xtext.example.mydsl.myDsl.*
import org.eclipse.xtext.common.types.JvmField
import sharedclasses.BaseTable
import org.eclipse.xtext.common.types.JvmConstructor

/**
 * <p>Infers a JVM model from the source model.</p> 
 *
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class MyDslJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	
	def dispatch void infer(Module module, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {

		// infer Table classes
		for (table : module.tables) {
			infer(table, acceptor, isPreIndexingPhase)
		}

		acceptor.accept(module.toClass(module.fullyQualifiedName)) [
			for (table : module.tables) {
				members += inferTableField(table)
			}
		]
	}

	/**
	 * Calculates the fully qualified name of the Table's class.<br>
	 * If the Table is contained (ie. by a IDC Checker or Module),
	 * then the class's simple name is constructed by the container's name and the Table's name. 
	 */
	def QualifiedName getTableClassQN(Table table) {
		var QualifiedName tableQN
		if (table.eContainer !== null) {
			tableQN = table.eContainer.fullyQualifiedName
		}
		if (tableQN === null) {
			tableQN = table.fullyQualifiedName
		}
		return tableQN.skipLast(1).append(tableQN.lastSegment + '_' + table.name)
	}

	/**
	 * Infers the Table's class and registers the class in the global repository. 
	 */
	def dispatch void infer(Table table, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val tableClassQN = getTableClassQN(table)
		val JvmGenericType tableClass = table.toClass(tableClassQN) [
			superTypes += BaseTable.typeRef
			val JvmConstructor constructor = table.toConstructor[]
			constructor.body = []
			members += constructor
		]
		acceptor.accept(tableClass)
	}

	/**
	 * Infers a field with the type of the Table's class taken from the global repository.
	 */
	def JvmField inferTableField(Table table) {
		val tableClassQN = getTableClassQN(table)
		return table.toField(table.name, tableClassQN.toString.typeRef) [
			initializer = [
				append('''
					new «tableClassQN.toString.typeRef.qualifiedName»()
				''')
			]
		]
	}
	
	def dispatch void infer(Checker checker, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {

		// infer Table classes
		for (table : checker.tables) {
			infer(table, acceptor, isPreIndexingPhase)
		}

		acceptor.accept(checker.toClass(checker.fullyQualifiedName)) [

			// process Use Table Declarations
			for (useTable : checker.useTables) {
				members += inferTableField(useTable.table)
			}

			// process Table Declarations
			for (table : checker.tables) {
				members += inferTableField(table)
			}

			// process Check Declarations
			for (check : checker.checks) {
				members += check.toMethod(check.name, void.typeRef) [
					body = check.body
				]
			}
		]
	}
}
